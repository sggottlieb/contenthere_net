Title: Calendar Feature Request: Meeting Buffers
Date: 2010-09-20T07:08:00Z
Modified: 2015-01-06T12:16:17.392Z
Category: misc
Tags: off-topic, Feature Request
Slug: 2010/09/calendar-feature-request-meeting-buffers
Authors: Seth Gottlieb

A while back I wrote [a post about how I use Google Calendar sharing to help my clients schedule me for meetings.](http://www.contenthere.net/2008/10/business-time.html) Recently, I have started to experiment with a service called [Tungle Me](http://tungle.me) that essentially does the same thing but allows people to create meeting requests too.  Calendar sharing is a great help but something is missing and I am surprised nobody has done anything about it.  
  
There is a big difference between my meeting schedule and my availability.  You can't assume that my availability equals all the gaps between my meetings because often I need to travel to and from a meeting and that makes time when I am not available.  My hack-ish work-around is to schedule two overlapping meetings: one to block off my travel time, and another for the actual meeting.  My colleague who is viewing my free/busy time calendar sees the two meetings as one block of time when I am unavailable.  I guess instead I could create events for my travel time before and after.  Both options are clumsy but they work.  
  
I was thinking a really useful feature for a calendaring system would be to add a "buffer time" field when you mark an event to "show as busy."  Buffer time would simply the number of minutes (before and after) to expand the event on your free/busy calendar.  It could be a text input with a syntax of "30" (for adding 30 minutes before and after the event) or "30,15" (for 30 minutes before and 15 minutes after).  Buffer time could also be useful on your personal, full-calendar view because it would tell you when you need to leave for your meeting.  I imagine this may pose a problem for calendaring systems that share a single meeting object between all of the attendees because each attendee will have different buffer times.  But this is not a problem that some good data modeling can't solve.  
  
Hopefully the collaboration vendors will start to build this capability into their products soon.  In the meantime, does anyone have a better work around than what I have been doing?
